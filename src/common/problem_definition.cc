#include <deal.II/base/utilities.h>

#include <sstream>
#include <utility>
#include <iomanip>

#include "problem_definition.h"

using namespace dealii;

ProblemDefinition::ProblemDefinition ()
{
}

ProblemDefinition::~ProblemDefinition()
{
}

void ProblemDefinition::declare_parameters (ParameterHandler &prm)
{
  // our final strategy is to declare all possible entries
  // and then ignore some of them suggested by Wolfgang Bangerth
  // from Colorado State on 05-10-2017
  // The following are the basic parameters we need to define a problem
  {
    prm.declare_entry ("problem dimension", "2", Patterns::Integer(), "1D is not implemented");
    prm.declare_entry ("transport model", "none", Patterns::Selection("ep|none"), "valid names such as ep");
    prm.declare_entry ("HO linear solver name", "cg", Patterns::Selection("cg|gmres|bicgstab|direct"), "solers");
    prm.declare_entry ("HO preconditioner name", "amg", Patterns::Selection("amg|parasails|bjacobi|jacobi|bssor"), "precond names");
    prm.declare_entry ("HO ssor factor", "1.0", Patterns::Double (), "damping factor of Block SSOR for HO");
    prm.declare_entry ("NDA linear solver name", "none", Patterns::Selection("none|gmres|bicgstab|direct"), "NDA linear solers");
    prm.declare_entry ("NDA preconditioner name", "none", Patterns::Selection("none|amg|parasails|bjacobi|jacobi|bssor"), "precond names");
    prm.declare_entry ("NDA ssor factor", "1.0", Patterns::Double (), "damping factor of Block SSOR for NDA");
    prm.declare_entry ("angular quadrature name", "none", Patterns::Selection ("lsgc|none"), "angular quadrature types. only LS-GC implemented for now.");
    prm.declare_entry ("angular quadrature order", "4", Patterns::Integer (), "Gauss-Chebyshev level-symmetric-like quadrature");
    prm.declare_entry ("number of groups", "1", Patterns::Integer (), "Number of groups in MG calculations");
    prm.declare_entry ("thermal group boundary", "0", Patterns::Integer (), "group number for the first thermal group");
    prm.declare_entry ("spatial discretization", "cfem", Patterns::Selection("dfem|cfem"), "USE DFEM or CFEM for spatial discretization");
    prm.declare_entry ("do eigenvalue calculations", "false", Patterns::Bool(), "Boolean to determine problem type");
    prm.declare_entry ("do NDA", "false", Patterns::Bool(), "Boolean to determine NDA or not");
    prm.declare_entry ("have reflective BC", "false", Patterns::Bool(), "");
    prm.declare_entry ("reflective boundary names", "", Patterns::List (Patterns::Anything ()), "must be lower cases of xmin,xmax,ymin,ymax,zmin,zmax");
    prm.declare_entry ("finite element polynomial degree", "1", Patterns::Integer(), "polynomial degree p for finite element");
    prm.declare_entry ("uniform refinements", "0", Patterns::Integer(), "number of uniform refinements desired");
    prm.declare_entry ("x, y, z max values of boundary locations", "", Patterns::List (Patterns::Double ()), "xmax, ymax, zmax of the boundaries, mins are zero");
    prm.declare_entry ("number of cells for x, y, z directions", "", Patterns::List (Patterns::Integer ()), "Geotry is hyper rectangle defined by how many cells exist per direction");
    prm.declare_entry ("number of materials", "1", Patterns::Integer (), "must be a positive integer");
    prm.declare_entry ("do print angular quadrature info", "true", Patterns::Bool(), "Boolean to determine if printing angular quadrature information");
    prm.declare_entry ("is mesh generated by deal.II", "true", Patterns::Bool(), "Boolean to determine if generating mesh in dealii or read in mesh");
    //prm.declare_entry ("use explicit reflective boundary condition or not", "true", Patterns::Bool(), "");
    prm.declare_entry ("output file name base", "solu", Patterns::Anything(), "name base of the output file");
    prm.declare_entry ("mesh file name", "mesh.msh", Patterns::Anything(), ".msh file name for read-in mesh");
  }
  // FixIt: for current deal.II code, we don't consider reading mesh
  
  // Explanation: we brute-forcely declare as many entries as possible without read-in problem-definition
  // parameters. nmat and ngrp should both be large enough s.t. when reading starts, the real setting will
  // have entry-declaration
  prm.enter_subsection ("material ID map");
  {
    prm.declare_entry ("material id file name", "mid.txt", Patterns::FileName(), "file name for material id map");
  }
  prm.leave_subsection ();
  
  prm.enter_subsection ("sigma_t, group=1 to G");
  {
    for (unsigned int m=0; m<nmat; ++m)
    {
      std::ostringstream os;
      os << "material " << m + 1;
      prm.declare_entry (os.str (), "", Patterns::List (Patterns::Double ()), "");
    }
  }
  prm.leave_subsection ();
  
  for (unsigned int m=0; m<nmat; ++m)
  {
    std::ostringstream os;
    os << "sigma_s, material " << m + 1;
    prm.enter_subsection (os.str());
    {
      for (unsigned int gin=0; gin<ngrp; ++gin)
      {
        std::ostringstream osm;
        osm << "g_in=" << gin + 1;
        prm.declare_entry (osm.str(), "", Patterns::List(Patterns::Double()), "multigroup sigma_s");
      }
    }
    prm.leave_subsection ();
  }
  
  prm.enter_subsection ("one-group sigma_t");
  {
    prm.declare_entry ("values", "", Patterns::List(Patterns::Double()), "");
  }
  prm.leave_subsection ();
  
  prm.enter_subsection ("one-group sigma_s");
  {
    prm.declare_entry ("values", "", Patterns::List(Patterns::Double()), "");
  }
  prm.leave_subsection ();
  
  prm.enter_subsection ("one-group Q");
  {
    prm.declare_entry ("values", "", Patterns::List(Patterns::Double()), "");
  }
  prm.leave_subsection ();
  
  prm.enter_subsection ("one-group chi");
  {
    prm.declare_entry ("values", "", Patterns::List(Patterns::Double()), "");
  }
  prm.leave_subsection ();
  
  prm.enter_subsection ("one-group nu_sigf");
  {
    prm.declare_entry ("values", "", Patterns::List(Patterns::Double()), "");
  }
  prm.leave_subsection ();
  
  prm.enter_subsection ("Q, group=1 to G");
  {
    for (unsigned int m=0; m<nmat; ++m)
    {
      std::ostringstream os;
      os << "material " << m + 1;
      prm.declare_entry (os.str (), "", Patterns::List (Patterns::Double ()), "");
    }
  }
  prm.leave_subsection ();
  
  // the following is for eigen problems
  prm.enter_subsection ("fissile material IDs");
  {
    prm.declare_entry ("fissile material ids", "", Patterns::List (Patterns::Integer ()), "");
  }
  prm.leave_subsection ();
  
  prm.enter_subsection ("chi, group=1 to G");
  {
    for (unsigned int m=0; m<nmat; ++m)
    {
      std::ostringstream os;
      os << "material " << m + 1;
      prm.declare_entry(os.str(), "", Patterns::List(Patterns::Double()), "");
    }
  }
  prm.leave_subsection ();
  
  prm.enter_subsection ("nu_sigf, group=1 to G");
  {
    for (unsigned int m=0; m<nmat; ++m)
    {
      std::ostringstream os;
      os << "material " << m + 1;
      prm.declare_entry(os.str(), "", Patterns::List(Patterns::Double()), "");
    }
  }
  prm.leave_subsection ();
}
