#include <deal.II/grid/grid_generator.h>
#include <deal.II/grid/grid_tools.h>
#include <deal.II/grid/tria_accessor.h>
#include <deal.II/grid/tria_iterator.h>
#include <deal.II/grid/grid_in.h>

#include <fstream>

#include "mesh_generator.h"

template <int dim>
MeshGenerator<dim>::MeshGenerator (ParameterHandler &prm)
:
is_mesh_generated(prm.get_bool("is mesh generated by deal.II")),
have_reflective_bc(prm.get_bool("have reflective BC")),
global_refinements(prm.get_integer("uniform refinements"))
{
  if (!is_mesh_generated)
    mesh_filename = prm.get ("mesh file name");
  else
  {
    process_coordinate_information (prm);
    initialize_relative_position_to_id_map (prm);
    preprocess_reflective_bc (prm);
  }
}

template <int dim>
MeshGenerator<dim>::~MeshGenerator ()
{
}

template <int dim>
void MeshGenerator<dim>::make_grid
(parallel::distributed::Triangulation<dim> &tria)
{
  if (is_mesh_generated)
  {
    generate_initial_grid (tria);
    initialize_material_id (tria);
    setup_boundary_ids (tria);
    tria.refine_global (global_refinements);
  }
  else
  {
    GridIn<dim> gi;
    gi.attach_triangulation (tria);
    std::ifstream f(mesh_filename);
    gi.read_msh (f);
  }
}

template <int dim>
void MeshGenerator<dim>::generate_initial_grid
(parallel::distributed::Triangulation<dim> &tria)
{
  Point<dim> origin;
  Point<dim> diagonal;
  switch (dim)
  {
    case 1:
    {
      diagonal[0] = axis_max_values[0];
      break;
    }
      
    case 2:
    {
      diagonal[0] = axis_max_values[0];
      diagonal[1] = axis_max_values[1];
      break;
    }
      
    case 3:
    {
      diagonal[0] = axis_max_values[0];
      diagonal[1] = axis_max_values[1];
      diagonal[2] = axis_max_values[2];
      break;
    }
      
    default:
      break;
  }
  GridGenerator::subdivided_hyper_rectangle (tria,
                                             ncell_per_dir,
                                             origin,
                                             diagonal);
}

template <int dim>
void MeshGenerator<dim>::initialize_material_id
(parallel::distributed::Triangulation<dim> &tria)
{
  AssertThrow (is_mesh_generated==true,
               ExcMessage("mesh read in have to have boundary ids associated"));
  for (typename Triangulation<dim>::active_cell_iterator
       cell=tria.begin_active(); cell!=tria.end(); ++cell)
    if (cell->is_locally_owned())
    {
      Point<dim> center = cell->center ();
      std::vector<unsigned int> relative_position (dim);
      get_cell_relative_position (center, relative_position);
      unsigned int material_id = relative_position_to_id[relative_position];
      cell->set_material_id (material_id);
    }
}

template <int dim>
void MeshGenerator<dim>::get_cell_relative_position (Point<dim> &center,
                                                     std::vector<unsigned int> &relative_position)
{
  AssertThrow (relative_position.size()==dim,
               ExcMessage("relative position should be size 3 for any dimension"));
  if (dim>=1)
  {
    relative_position[0] = static_cast<unsigned int>(center[0] / cell_size_all_dir[0]);
    if (dim>=2)
    {
      relative_position[1] = static_cast<unsigned int>(center[1] / cell_size_all_dir[1]);
      if (dim==3)
        relative_position[2] = static_cast<unsigned int>(center[2] / cell_size_all_dir[2]);
    }
  }
}

template <int dim>
void MeshGenerator<dim>::setup_boundary_ids
(parallel::distributed::Triangulation<dim> &tria)
{
  AssertThrow (is_mesh_generated==true,
               ExcMessage("mesh read in have to have boundary ids associated"));
  AssertThrow (axis_max_values.size()==dim,
               ExcMessage("number of entries axis max values should be dimension"));
  
  for (typename Triangulation<dim>::active_cell_iterator
       cell=tria.begin_active(); cell!=tria.end(); ++cell)
    if (cell->is_locally_owned())
      for (unsigned int fn=0; fn<GeometryInfo<dim>::faces_per_cell; ++fn)
        if (cell->at_boundary(fn))
        {
          Point<dim> ct = cell->face(fn)->center();
          // x-axis boundaries
          if (std::fabs(ct[0])<1.0e-14)
            cell->face(fn)->set_boundary_id (0);
          else if (std::fabs(ct[0]-axis_max_values[0])<1.0e-14)
            cell->face(fn)->set_boundary_id (1);
          
          // 2D and 3D boundaries
          if (dim>1)
          {
            // y-axis boundaries
            if (std::fabs(ct[1])<1.0e-14)
              cell->face(fn)->set_boundary_id (2);
            else if (std::fabs(ct[1]-axis_max_values[1])<1.0e-14)
              cell->face(fn)->set_boundary_id (3);
            
            // z-axis boundaries
            if (dim==3)
            {
              if (std::fabs(ct[2])<1.0e-14)
                cell->face(fn)->set_boundary_id (4);
              else if (std::fabs(ct[2]-axis_max_values[2])<1.0e-14)
                cell->face(fn)->set_boundary_id (5);
            }
          }
        }
}

template <int dim>
void MeshGenerator<dim>::process_coordinate_information (ParameterHandler &prm)
{
  AssertThrow (dim>1,
               ExcMessage("1D is not implemented."));
  // max values for all axis
  std::vector<std::string> strings = Utilities::split_string_list (prm.get ("x, y, z max values of boundary locations"));
  AssertThrow (strings.size()>=dim,
               ExcMessage("Number of axis max values must be no less than dimension"));
  for (unsigned int i=0; i<dim; ++i)
    axis_max_values.push_back (std::atof (strings[i].c_str()));
  
  // read in number of cells and get cell sizes along axes
  strings = Utilities::split_string_list (prm.get ("number of cells for x, y, z directions"));
  AssertThrow (strings.size()>=dim,
               ExcMessage ("Entries for numbers of cells must be no less than dimension"));
  std::vector<unsigned int> cells_per_dir;
  std::vector<std::vector<double> > spacings;
  for (unsigned int d=0; d<dim; ++d)
  {
    ncell_per_dir.push_back (std::atoi (strings[d].c_str ()));
    cell_size_all_dir.push_back (axis_max_values[d]/ncell_per_dir[d]);
  }
}

template <int dim>
void MeshGenerator<dim>::preprocess_reflective_bc (ParameterHandler &prm)
{
  if (have_reflective_bc)
  {
    std::map<std::string, unsigned int> bd_names_to_id
    {{"xmin",0}, {"xmax",1}, {"ymin",2}, {"ymax",3}, {"zmin",4}, {"zmax",5}};
    std::vector<std::string> strings = Utilities::split_string_list (prm.get ("reflective boundary names"));
    AssertThrow (strings.size()>0,
                 ExcMessage("reflective boundary names have to be entered"));
    std::set<int> tmp;
    for (unsigned int i=0; i<strings.size (); ++i)
    {
      AssertThrow(bd_names_to_id.find(strings[i])!=bd_names_to_id.end(),
                  ExcMessage("Invalid reflective boundary name: use xmin, xmax, etc."));
      tmp.insert (bd_names_to_id[strings[i]]);
    }
    auto it = tmp.begin ();
    std::ostringstream os;
    os << "No valid reflective boundary name for " << dim << "D";
    AssertThrow(*it<2*dim,
                ExcMessage(os.str()));
    for (unsigned int i=0; i<2*dim; ++i)
    {
      if (tmp.count (i))
        is_reflective_bc[i] = true;
      else
        is_reflective_bc[i] = false;
    }
  }
}

template <int dim>
void MeshGenerator<dim>::get_relevant_cell_iterators
(const DoFHandler<dim> &dof_handler,
 std::vector<typename DoFHandler<dim>::active_cell_iterator> &local_cells)
{
  for (typename DoFHandler<dim>::active_cell_iterator
       cell=dof_handler.begin_active();
       cell!=dof_handler.end(); ++cell)
    if (cell->is_locally_owned())
      local_cells.push_back (cell);
}

template <int dim>
void MeshGenerator<dim>::initialize_relative_position_to_id_map (ParameterHandler &prm)
{
  prm.enter_subsection ("material ID map");
  {
    unsigned int ncell_z = dim==3?ncell_per_dir[2]:1;
    unsigned int ncell_y = dim>=2?ncell_per_dir[1]:1;
    unsigned int ncell_x = ncell_per_dir[0];
    std::string id_fname = prm.get ("material id file name");
    std::ifstream in (id_fname);
    std::string line;
    unsigned int ct = 0;
    if (in.is_open ())
    {
      while (std::getline (in, line))
      {
        unsigned int y = ct % ncell_y;
        unsigned int z = ct / ncell_y;
        std::vector<std::string> strings = Utilities::split_string_list (line, ' ');
        AssertThrow (strings.size()==ncell_x,
                     ExcMessage("Entries of material ID per row must be ncell_x"));
        for (unsigned int x=0; x<ncell_x; ++x)
        {
          std::vector<unsigned int> tmp {x, y, z};
          relative_position_to_id[tmp] = std::atoi (strings[x].c_str()) - 1;
        }
        ct += 1;
      }
      AssertThrow (ct==ncell_y*ncell_z,
                   ExcMessage("Number of y, z ID entries are not correct"));
      in.close ();
    }
  }
  prm.leave_subsection ();
}

template <int dim>
std::unordered_map<unsigned int, bool>
MeshGenerator<dim>::get_reflective_bc_map ()
{
  return is_reflective_bc;
}

template <int dim>
unsigned int MeshGenerator<dim>::get_uniform_refinement ()
{
  return global_refinements;
}

template class MeshGenerator<2>;
template class MeshGenerator<3>;
